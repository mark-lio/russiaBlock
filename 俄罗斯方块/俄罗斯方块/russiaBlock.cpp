#include<stdio.h>
#include<graphics.h>
#include<iostream>
#include<time.h>
#include<conio.h>//kbhit()所需的头文件
#include<mmsystem.h>
#pragma comment(lib, "winmm.lib")

using namespace std;

#define BLOCK_COUNT  5
#define BLOCK_WIDTN  5
#define BLOCK_HEIGHT 5
#define UNIT_SIZE    20//小方块像素
#define START_X     130
#define START_Y      30
#define KEY_UP       72     //↑方向键ASCII码值
#define KEY_DOWN     80     //↓方向键ASCII码值
#define KEY_LEFT     75     //←方向键ASCII码值
#define KEY_RIGHT    77     //→方向键ASCII码值
#define KEY_SPACE    32		//空格键ASCII码值

typedef enum{
	BLOCK_UP,
	BLOCK_RIGHT,
	BLOCK_DOWN,
	BLOCK_LEFT
}block_dir;

typedef enum{
	MOVE_DOWN,
	MOVE_LEFT,
	MOVE_RIGHT
}move_dir;

int level = 0;//等级
int score = 0;//分数
int NextIndex = -1;//下一个方块的种类
int BlockIndex = -1;//当前方块的种类
int speed = 500;
int minX = 30;
int minY = 30;

int color[BLOCK_COUNT] = {
	GREEN, CYAN, MAGENTA, BROWN, YELLOW
};

int visit[30][15];//访问数组
int markColor[30][15];

int block[BLOCK_COUNT * 4][BLOCK_HEIGHT][BLOCK_WIDTN] = {//每种方块有四种形态
	//条形方块
	{
		0, 0, 0, 0, 0,
		0, 0, 1, 0, 0,
		0, 0, 1, 0, 0,
		0, 0, 1, 0, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
		0, 1, 1, 1, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 0, 1, 0, 0,
		0, 0, 1, 0, 0,
		0, 0, 1, 0, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
		0, 1, 1, 1, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
	},

	//L形方块
	{
		0, 0, 0, 0, 0,
		0, 0, 1, 0, 0,
		0, 0, 1, 0, 0,
		0, 0, 1, 1, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 1, 0,
		0, 1, 1, 1, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 0, 1, 1, 0,
		0, 0, 0, 1, 0,
		0, 0, 0, 1, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 1, 1, 1, 0,
		0, 1, 0, 0, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
	},

	//田字形方块
	{
		0, 0, 0, 0, 0,
		0, 1, 1, 0, 0,
		0, 1, 1, 0, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 1, 1, 0, 0,
		0, 1, 1, 0, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 1, 1, 0, 0,
		0, 1, 1, 0, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 1, 1, 0, 0,
		0, 1, 1, 0, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
	},

	//T形方块
	{
		0, 0, 0, 0, 0,
		0, 1, 1, 1, 0,
		0, 0, 1, 0, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 0, 0, 1, 0,
		0, 0, 1, 1, 0,
		0, 0, 0, 1, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 0, 1, 0, 0,
		0, 1, 1, 1, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 1, 0, 0, 0,
		0, 1, 1, 0, 0,
		0, 1, 0, 0, 0,
		0, 0, 0, 0, 0,
	},

	//Z形方块
	{
		0, 0, 0, 0, 0,
		0, 1, 1, 0, 0,
		0, 0, 1, 1, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 0, 1, 1, 0,
		0, 1, 1, 0, 0,
		0, 0, 0, 0, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 0, 1, 0, 0,
		0, 1, 1, 0, 0,
		0, 1, 0, 0, 0,
		0, 0, 0, 0, 0,
	},
	{
		0, 0, 0, 0, 0,
		0, 1, 0, 0, 0,
		0, 1, 1, 0, 0,
		0, 0, 1, 0, 0,
		0, 0, 0, 0, 0,
	}
};


//欢迎界面
void welcome(void){
	//初始化画布
	initgraph(550,660);

	//设置窗口标题
	HWND window=GetHWnd();//获取当前窗口
	SetWindowText(window, _T("俄罗斯方块----*Coding_King*"));//设置窗口标题

	//设置文本的字体样式
	settextstyle(40, 0, _T("华文行楷"));//高度40,宽度不指定(自适应),字体
	setcolor(GREEN);
	outtextxy(205, 200, _T("俄罗斯方块"));

	settextstyle(22, 0, _T("华文行楷"));
	setcolor(YELLOW);
	outtextxy(191, 300, _T("编程,从俄罗斯方块开始!"));

	Sleep(4000);//毫秒

}


//初始化游戏场景
void initGameScene(void){
	mciSendString("play lonelyDance.mp3 repeat", 0, 0, 0);
	char str[16];

	cleardevice();//清除屏幕

	rectangle(27, 27, 336, 635);
	rectangle(29, 29, 334, 633);
	rectangle(370, 50, 515, 195);

	settextstyle(24, 0, _T("华文行楷"));
	setcolor(LIGHTGRAY);
	outtextxy(405, 215, _T("下一个"));

	setcolor(RED);
	outtextxy(405, 280, _T("分数"));
	sprintf_s(str, "%d", score);
	outtextxy(425, 310, str);
	
	outtextxy(405, 375, _T("等级"));
	sprintf_s(str, "%d", level);
	outtextxy(425, 405, str);

	//操作说明
	setcolor(LIGHTBLUE);
	outtextxy(390, 475, "操作说明");
	outtextxy(390, 500, "↑:旋转");
	outtextxy(390, 525, "↓:下降");
	outtextxy(390, 550, "←:左移");
	outtextxy(390, 575, "→:右移");
	outtextxy(390, 600, "空格:暂停");


}

//清除右上角区域(的方块)
void clearBlock(void){
	setcolor(BLACK);
	settextstyle(23, 0, "楷体");
	for (int i = 0; i < BLOCK_HEIGHT; i++){
		for (int j = 0; j < BLOCK_WIDTN; j++){
			int x = 391 + j*UNIT_SIZE;
			int y = 71 + i*UNIT_SIZE;
			outtextxy(x, y, "■");
		}
	}

}

//函数重载
//清除指定位置指定方向的方块
//参数x:方块左上角的x坐标
//参数y:方块的左上角在游戏区域内的坐标,距离游戏区域顶部的距离
void clearBlock(int x,int y,block_dir dir){
	setcolor(BLACK);
	int id = BlockIndex * 4 + dir;

	for (int i = 0; i < BLOCK_HEIGHT; i++){
		for (int j = 0; j < BLOCK_WIDTN; j++){
			if (block[id][i][j] == 1){
				//擦除该方块的第i行第j列
				outtextxy(x + j*UNIT_SIZE, y + i*UNIT_SIZE + START_Y,"■");
			}
		}
	}
}


//在右上角区域中绘制下一个方块
void drawBlock(int x,int y){
	setcolor(color[NextIndex]);
	settextstyle(23, 0, "楷体");
	for (int i = 0; i < BLOCK_HEIGHT; i++){
		for (int j = 0; j < BLOCK_WIDTN; j++){
			if (block[NextIndex * 4][i][j] == 1){
				int x1 = x + j*UNIT_SIZE;
				int y1 = y + i*UNIT_SIZE;
				outtextxy(x1, y1, "■");
			}
		}
	}
}

//绘制当前方块,在指定位置绘制指定方块的指定方向
void drawBlock(int x, int y, int blockIndex, block_dir dir){
	setcolor(color[blockIndex]);
	settextstyle(23, 0, "楷体");
	int id = blockIndex * 4 + dir;
	for (int i = 0; i < BLOCK_HEIGHT; i++){
		for (int j = 0; j < BLOCK_WIDTN; j++){
			if (block[id][i][j] == 1){
				int x1 = x + j*UNIT_SIZE;
				int y1 = y + i*UNIT_SIZE;
				outtextxy(x1, y1, "■");
			}
		}
	}
}

void nextblock(void){
	clearBlock();

	//随机选择一种方块
	srand(time(NULL));//使用时间函数的返回值来作为随机种子
	NextIndex = rand() % BLOCK_COUNT;
	
	drawBlock(391,71);

}

//如果在指定位置可以向指定方向移动,就返回1,否则就返回0
int moveable(int x0, int y0, move_dir moveDir, block_dir blockDir){
	int id = BlockIndex * 4 + blockDir;//第几个方块
	
	//计算当前方块的左上角在30*15的游戏区中的位置(第多少行,第多少列)
	int x = (y0 - minY) / UNIT_SIZE;
	int y = (x0 - minX) / UNIT_SIZE;

	int ret = 1;

	if (moveDir == MOVE_DOWN){
		for (int i = 0; i < BLOCK_HEIGHT; i++){
			for (int j = 0; j < BLOCK_WIDTN; j++){
				if (block[id][i][j] == 1 &&//等于1表示当前是小方块
					(x + i + 1 >= 30 ||
					visit[x + i + 1][y + j] == 1)){
					ret = 0;
				}
			}
		}
	}
	else if (moveDir == MOVE_LEFT){
		for (int i = 0; i < BLOCK_HEIGHT; i++){
			for (int j = 0; j < BLOCK_WIDTN; j++){
				if (block[id][i][j] == 1 &&//等于1表示当前是小方块
					(y+j==0 ||
					visit[x + i ][y + j-1] == 1)){
					ret = 0;
				}
			}
		}
	}
	else if (moveDir == MOVE_RIGHT){
		for (int i = 0; i < BLOCK_HEIGHT; i++){
			for (int j = 0; j < BLOCK_WIDTN; j++){
				if (block[id][i][j] == 1 &&//等于1表示当前是小方块
					(y + j +1>= 15 ||
					visit[x + i][y + j +1] == 1)){
					ret = 0;
				}
			}
		}
	}
	return ret;
}

void failCheck(void){
	if (!moveable(START_X, START_Y, MOVE_DOWN, BLOCK_UP)){
		setcolor(RED);
		settextstyle(44, 0, "华文楷体");
		outtextxy(59, 299, "GAME OVER!");
		Sleep(4000);
		system("pause");
		closegraph();
		exit(0);
	}
}

void wait(int interval){
	int count = interval / 10;
	for (int i = 0; i < count; i++){
		Sleep(10);
		if (_kbhit()){
			return;
		}
	}
}

//判断当前方块是否可以转向到指定方向
//注意,此时还没有转到该方向!
int rotatable(int x, int y , block_dir nextDir){
	int id = BlockIndex * 4 + nextDir;
	int xIndex = (y - minY) / UNIT_SIZE;
	int yIndex = (x - minX) / UNIT_SIZE;
	if (!moveable(x, y, MOVE_DOWN, nextDir)){
		return 0;
	}

	for (int i = 0; i < BLOCK_HEIGHT; i++){
		for (int j = 0; j < BLOCK_WIDTN; j++){
			if (block[id][i][j] == 1 &&
				(yIndex + j < 0 || yIndex + j >= 15 || visit[xIndex + i][yIndex + j] == 1)){
				return 0;
			}
		}
	}
	return 1;
}

//固定方块
void mark(int x, int y, int blockIndex, block_dir dir){
	int id = blockIndex * 4 + dir;
	int x1 = (y - minY)/20;
	int y1 = (x - minX)/20;
	for (int i = 0; i < BLOCK_HEIGHT; i++){
		for (int j = 0; j < BLOCK_WIDTN; j++){
			if (block[id][i][j] == 1){
				visit[x1 + i][y1 + j] = 1;
				markColor[x1 + i][y1 + j] = color[blockIndex];
			}
		}
	}
}

void move(void){
	int x = START_X;
	int y = START_Y;
	int k = 0;
	block_dir blockDir=BLOCK_UP;
	int curSpeed = speed;

	failCheck();//检测游戏是否结束
	
	//持续向下降落
	while (1){
		if (_kbhit()){
			int key = _getch();
			if (key == KEY_SPACE){
				_getch();
			}
		}

		//清除当前方块
		clearBlock(x, k, blockDir);

		if (_kbhit()){
			int key = _getch();
			if (key == KEY_UP){
				block_dir nextDir = (block_dir)((blockDir + 1) % 4);
				if (rotatable(x, y + k, nextDir)){
					blockDir = nextDir;
				}
			}
			else if (key == KEY_DOWN){
				curSpeed = 50;
			}
			else if (key == KEY_LEFT){
				if (moveable(x, y + k + UNIT_SIZE, MOVE_LEFT, blockDir)){
					x -= UNIT_SIZE;
				}
			}
			else if (key == KEY_RIGHT){
				if (moveable(x, y + k + UNIT_SIZE, MOVE_RIGHT, blockDir)){
					x += UNIT_SIZE;
				}
			}
		}

		k += 20;

		//绘制当前方块
		drawBlock(x, y + k, BlockIndex, blockDir);

		wait(curSpeed);
		
		

		//方块的"固化"处理(降到底部就不会动了)
		if (!moveable(x, y + k, MOVE_DOWN, blockDir)){
			mark(x, y + k, BlockIndex, blockDir);
			break;
		}
	}


}

void newblock(void){
	//确定即将使用的方块的种类
	BlockIndex = NextIndex;
	

	//绘制刚从顶部下降的方块
	drawBlock(START_X, START_Y);
	
	//让新出现的方块暂停一会,让用户识别到
	Sleep(100);

	//在右上角区域绘制下一个方块
	nextblock();

	//方块降落
	move();

}

//消除第i行,并把上面的行都下移
void down(int x){
	for (int i = x; i > 0; i--){
		for (int j = 0; j < 15; j++){//消除第i行,第j列的方块消除
			if (visit[i - 1][j]){
				visit[i][j] = 1;
				markColor[i][j] = markColor[i - 1][j];
				setcolor(markColor[i][j]);
				outtextxy(j*UNIT_SIZE+minX, i*UNIT_SIZE+minY, "■");
			}
			else{
				visit[i][j] = 0;
				setcolor(BLACK);
				outtextxy(j*UNIT_SIZE + minX, i*UNIT_SIZE + minY, "■");
			}
		}
	}

	//清除最顶上的那一行(即行标为0的那一行)
	setcolor(BLACK);
	for (int j = 0; j < 15; j++){
		visit[0][j] = 0;
		outtextxy(j*UNIT_SIZE + minX,  minY, "■");
	}

}

//更新分数,参数lines表示消除的行数
void addScore(int lines){
	char str[32];
	setcolor(RED);
	score += lines * 10;
	sprintf_s(str, "%d", score);
	outtextxy(425, 310, str);
}

void updateLevel(void){
	//更新等级的提示
	level = score / 100;//假设100分一级
	char str[32];
	sprintf_s(str, "%d", level);
	setcolor(RED);
	outtextxy(425, 405, str);

	//更新速度,等级越高,速度越快,speed越小!
	//在这里,最慢:500ms,最快:100ms
	speed = 500 - level * 10;
	if (speed <= 100){
		speed = 100;
	}
	
}

void check(void){
	int i, j;
	int clearLines = 0;
	for ( i = 29; i >= 0; i--){
		for ( j = 0; j < 15 && visit[i][j]; j++);//检查第i行有没有满

		//执行到此处时,有两种情况:
		//1.第i行没有满,即有空位,此时j<15
		//2.第i行已满了,此时j>=15
		if (j >= 15){
			//此时第i行已满,需要消除第i行
			down(i);//消除第i行,并把上面的行都下移
			i++;//因为最外层的循环中有i--,所以先i++,使得下次循环时再把这一行检查一下
			clearLines++;
		}
	}

	//更新分数
	addScore(clearLines);

	//更新等级,等级越高,速度越快
	updateLevel();
}

int main(void){
	welcome();
	initGameScene();

	//产生新方块
	nextblock();
	Sleep(500);

	//初始化访问数组
	memset(visit, 0, sizeof(visit));

	while (1){
		newblock();

		//消除满行,并更新分数和等级
		check();

	}
	
	system("pause");
	closegraph();
	return 0;
}